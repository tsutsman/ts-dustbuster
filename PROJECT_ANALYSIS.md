# Аналітика проєкту ts-dustbuster

## 1. Загальна характеристика

- **Призначення:** кросплатформений інструмент очищення тимчасових файлів і кешів із CLI та простим веб‑інтерфейсом.
- **Цільові користувачі:** DevOps/адміністратори, які потребують автоматизованого очищення робочих станцій і CI-агентів; просунуті користувачі, що хочуть контролювати очищення локальної системи.
- **Технології:** Node.js (мінімальна підтримувана версія 16), стандартна бібліотека, залежність `yaml` для читання конфігурацій.【F:cleaner.js†L1-L139】【F:package.json†L1-L14】
- **Способи запуску:** shell/PowerShell/cmd-обгортки для різних ОС та Node.js‑скрипт `cleaner.js`; веб‑сервер `gui.js` для запуску через браузер.【F:README.md†L5-L71】【F:gui.js†L1-L29】

## 2. Архітектура та модулі

### 2.1 CLI (`cleaner.js`)

- **Парсинг аргументів:** підтримуються прапорці `--dry-run`, `--parallel`, `--concurrency`, `--max-age`, `--dir`, `--exclude`, `--config`, `--preset`, `--preview`, `--summary`, `--log` тощо. Значна частина логіки присвячена валідації та об’єднанню конфігурацій/пресетів.【F:cleaner.js†L120-L453】
- **Конфігурації:**
  - Можна завантажувати JSON/YAML файли, каталоги з конфігами та комбінувати їх через пресети.
  - Конфіг дані нормалізуються й можуть включати інші пресети, підтримується перевизначення налаштувань і накопичення директорій/виключень.【F:cleaner.js†L320-L520】
- **Основні можливості очищення:**
  - Рекурсивне видалення файлів із підрахунком метрик (файли/теки/байти/пропуски/помилки).
  - Врахування вікового фільтра (`--max-age`), списку виключень, режиму dry-run, паралельного виконання (через чергу промісів) і глибокого очищення.
  - Інтерактивний режим `--preview` із попереднім підрахунком вмісту та підтвердженням від користувача; передбачене ін’єкційне API для моків у тестах.【F:cleaner.js†L140-L319】【F:cleaner.js†L520-L760】
- **Системна інтеграція:**
  - Функція `ensureNodeVersion` перевіряє версію Node.js, shell-скрипти встановлюють залежності та додають системні директорії до списку очищення.
  - Підтримуються стандартні шляхи для Windows, macOS, Linux через умовні блоки (огляд у `pushIfExists`/`detectDefaultTargets`).

### 2.2 GUI (`gui.js` + `public/index.html`)

- Примітивний HTTP-сервер, який повертає статичну HTML-сторінку та виконує очищення при POST `/clean`.
- Логи очищення збираються в пам’яті та повертаються клієнту як plain text.【F:gui.js†L1-L29】
- GUI не має авторизації, обробки помилок та розмежування доступу; використовується синхронне читання HTML під час старту.

### 2.3 Shell-обгортки

- `cleaner.sh`, `cleaner.cmd`, `cleaner-macos.sh` забезпечують виявлення Node.js, установку (через пакетні менеджери) та запуск `cleaner.js` із правильними параметрами (наприклад, `--deep` для Windows).【F:README.md†L9-L47】

## 3. Якість коду й тестування

- Є модульні тести `test.js`, які покривають ключові сценарії: очищення директорій, dry-run, max-age, виключення, комбіновані конфіги, пресети, інтерактивний режим. Тести запускалися вручну (`node test.js`).【F:test.js†L1-L200】【4734d3†L1-L24】
- Вимірювач покриття відсутній; фактичний рівень покриття не перевіряється, але тести охоплюють основні гілки CLI.
- Немає автоматичних лінтерів чи форматерів у `package.json`; відсутня інтеграція з CI.

## 4. Документація та UX

- `README.md` містить базову інструкцію з запуску та опис ключових опцій, але інформація подана двома мовами й частково дублюється.
- `ROADMAP.md` містив високорівневі етапи без конкретних критеріїв готовності; потребує оновлення для реалістичного планування.
- Немає довідника з налаштувань (з прикладами JSON/YAML), best practices для використання в CI, таблиці підтримуваних директорій.

## 5. Залежності та безпека

- Єдина зовнішня залежність — `yaml`. Це зменшує поверхню атаки, але потребує регулярних оновлень.
- Скрипт виконує операції видалення без sandbox; відсутні захисні механізми проти випадкового видалення критичних файлів (крім виключень).
- GUI без авторизації може бути ризикованим у мережевому середовищі; слід запускати лише локально.

## 6. Сильні сторони

- Гнучка система конфігурацій і пресетів із комбінуванням та перевизначеннями.
- Підтримка dry-run, метрик, інтерактивного попереднього перегляду.
- Мінімальні залежності та кросплатформені shell-обгортки.

## 7. Технічний борг і ризики

- **Відсутність модульності:** `cleaner.js` містить і CLI, і бізнес-логіку; складно тестувати окремі частини й повторно використовувати в GUI.
- **Бракує багатомовності:** хоч у коді є українські повідомлення, немає централізованої системи локалізацій.
- **Обмежене логування:** лог-файл ведеться простим append без ротації чи форматування JSON; немає рівнів логування.
- **Масштабованість паралельності:** реалізація паралельного видалення обмежена ручним керуванням промісами; немає контролю обмеження ресурсів.
- **Відсутність CI/CD:** немає автоматизованих тестів, лінтерів, security-сканів, release pipeline.
- **GUI мінімалістичний:** відсутні стани виконання, інтернаціоналізація, авторизація, керування конфігами.
- **Перевірки прав доступу:** очищення системних директорій може вимагати прав адміністратора; немає попереджень чи fallback.

## 8. Бізнес-вимоги та сценарії використання

1. **Ручне очищення на робочій станції.** Важлива прозорість (dry-run, preview) і можливість налаштувати пресет.
2. **Автоматичне очищення в CI/CD.** Потрібно безпечне логування, exit-коди, інтеграція з планувальниками.
3. **Централізоване керування в команді.** Потрібні загальні конфіги, підписані релізи, контроль доступу до GUI/API.

## 9. Критерії успіху (оновлені)

- Покриття ключової логіки тестами ≥80% та автоматичний звіт у CI.
- Публікація офіційних релізів з підписом, changelog і перевіркою сум.
- Безпечний режим за замовчуванням: dry-run, підтвердження перед видаленням, whitelist цільових директорій.
- GUI/CLI із локалізацією та зрозумілою аналітикою очищення.
- Можливість інтегруватися через API/SDK у зовнішні системи.

## 10. Рекомендації короткострокові

- Розділити `cleaner.js` на модулі: парсер аргументів, ядро очищення, робота з конфігами.
- Додати ESLint/Prettier, GitHub Actions для тестів і лінтерів.
- Створити довідник конфігурацій із прикладами та типовими пресетами.
- Підготувати набір smoke-тестів для shell-скриптів.
- Запровадити логування у форматі JSON з можливістю вибору рівнів.

## 11. Середньострокові кроки

- Побудувати модуль локалізації (наприклад, через i18next) і винести повідомлення в окремі файли.
- Реалізувати планувальник завдань (cron/Task Scheduler/launchd) через окремі скрипти або документацію.
- Покращити паралельність через пул воркерів, обмеження IO й тайм-аути.
- Розширити GUI: показ статусу, прогрес, журнал, завантаження/редагування конфігів.

## 12. Довгострокове бачення

- Надати REST/GraphQL API з аутентифікацією та ролями.
- Запровадити плагінну систему для цільових платформ (Docker, IDE, Kubernetes).
- Упакувати застосунок в Electron/Tauri з автооновленням і підписами.
- Створити спільнотну інфраструктуру: шаблони issue/PR, CONTRIBUTING, автоматичний changelog.
